#!/usr/bin/env python3
import math
import wpilib
from wpilib import Timer

class MyRobot(wpilib.TimedRobot):
   
    test_cmd_vx = 0.0
    test_cmd_vy = 0.0
    test_cmd_vz = 0.0
   
    def robotInit(self):
        self.sd = wpilib.SmartDashboard

        # command inputs (ROS -> NT -> robot)
        self.cmd_vx = 0.0
        self.cmd_vy = 0.0
        self.cmd_wz = 0.0

        # simple internal state for test odom
        self.x = 0.0
        self.y = 0.0
        self.yaw = 0.0

        self.last_t = Timer.getFPGATimestamp()
        self.heartbeat = 0

        # Seed keys so dashboards show them immediately
        self.sd.putNumber("cmd_vel_vx_mps", 0.0)
        self.sd.putNumber("cmd_vel_vy_mps", 0.0)
        self.sd.putNumber("cmd_vel_wz_radps", 0.0)

        self.sd.putNumber("odom_x_m", 0.0)
        self.sd.putNumber("odom_y_m", 0.0)
        self.sd.putNumber("odom_yaw_rad", 0.0)
        self.sd.putNumber("odom_vx_mps", 0.0)
        self.sd.putNumber("odom_vy_mps", 0.0)
        self.sd.putNumber("odom_wz_radps", 0.0)
        self.sd.putNumber("robot_heartbeat", 0)

    def robotPeriodic(self):
        # Keep a heartbeat that increments even when disabled
        self.heartbeat += 1
        self.sd.putNumber("robot_heartbeat", float(self.heartbeat))

    def teleopPeriodic(self):

        global test_cmd_vx
        global test_cmd_vy
        global test_cmd_vz

        now = Timer.getFPGATimestamp()
        dt = max(1e-3, now - self.last_t)
        self.last_t = now

        # Read command keys (written by ROS bridge)
        self.cmd_vx = float(self.sd.getNumber("cmd_vel_vx_mps", 0.0))
        self.cmd_vy = float(self.sd.getNumber("cmd_vel_vy_mps", 0.0))
        self.cmd_wz = float(self.sd.getNumber("cmd_vel_wz_radps", 0.0))

        # Very simple integration (body velocities -> world)
        self.yaw += self.cmd_wz * dt

        cy = math.cos(self.yaw)
        sy = math.sin(self.yaw)

        # rotate body (vx, vy) into world frame
        vx_w = self.cmd_vx * cy - self.cmd_vy * sy
        vy_w = self.cmd_vx * sy + self.cmd_vy * cy

        # Increment and set test nubmers known values
        test_cmd_vx += 0.1
        test_cmd_vy += 0.5
        test_cmd_vz += 1.0

        self.x += 0.1
        self.y += 0.5
        self.yaw += 1.0

        # Uncomment the below when we have a sensor on the RoboRIO
        # self.x += vx_w * dt
        # self.y += vy_w * dt

        # Publish odom keys (read by ROS bridge)
        self.sd.putNumber("odom_x_m", self.x)
        self.sd.putNumber("odom_y_m", self.y)
        self.sd.putNumber("odom_yaw_rad", self.yaw)

        self.sd.putNumber("odom_vx_mps", self.cmd_vx)
        self.sd.putNumber("odom_vy_mps", self.cmd_vy)
        self.sd.putNumber("odom_wz_radps", self.cmd_wz)

    def disabledInit(self):
        # Reset timing so dt doesn't spike on re-enable
        self.last_t = Timer.getFPGATimestamp()


if __name__ == "__main__":
    wpilib.run(MyRobot)


